# University_Programming_work
1. 고전 레이싱게임
  처음으로 배운 파이썬 자율 과제 안에서 평소에 관심이 많던 게임을 만들자고 결심했고 기본적인 레이싱게임을 만들어서 기초를 다져야겠다고 생각했습니다. 이미지와 효과음들은 무료소스로서 차근차근 구체화 시켜나갔습니다. 기본적인 배경을 설정해두고 케릭터에 방향키를 설정해준후에 각종 차가 랜덤으로 위에서 내려오는 방식으로 코딩을 했습니다. 
  
  처음으로 배운 컴퓨터 언어인 파이썬으로 했던 개인프로젝트였던 터라 생각보다 쉽지않았지만, 그래도 제가 어느정도 구상했던대로 결과를 얻어서 저에게있어선 상당히 의미있는 과제였습니다. 시간이 적게 걸리진 않았지만 제가 머릿속에서 생각했던 이미지들을 코드로서 실제로 표현한다는 것이 가장 흥미로웠습니다. 마지막으로 첫 과제를 통해 자신감을 얻었습니다. 좌표를통해 직선적인 움직임에대한 코드에대해 어느정도 익숙해졌으며 이론으로만 배웠던 코드의 기본인 While 문, If 문, for 문 등을 게임에 직접 대입하고 연습했기때문에 다음에 있을 조금 더 복잡한 코딩에 더 쉽게 적용하고 응용할수 있을것 같습니다. 
  
  레이싱 게임에 대한 조작법입니다.
  spacebar를 눌러 게임을 시작합니다.
  기본적인 키는 방향키를 사용하여 오토바이를 움직입니다.
  오래 버틸수록 점수가 올라갑니다.
  R 키로 재시작이 가능합니다.
  P를 누르면 pause 기능이 있습니다.

2. 시저사이퍼
  시저 사이퍼란 알파벳을 원하는 숫자만큼 평행으로 밀거나 당겨서 행해지는 암호화 입니다. 기본적인 시저사이퍼의 사용법은 Encrypt (E) Decrypt (D) 를 선택한후에 알파벳순서를 얼마만큼 쉬프트 하고싶은지 숫자를 선택후에 원하는 텍스트를 넣는 방법입니다. 예를들어, ./caesar_cipher.py d 5 Mjqqt Btwqi!인풋을 넣는다면 Hello World!의 아웃풋을 얻을수 있습니다. 이 워크는 우분투를 통해 이루어졌으며, 시저 사이퍼 코드를 설계하면서 주어진 테스트 코드를 통해 원하는 결과 값을 얻기 위함입니다. 
  
  시저 사이퍼코드를 만들었다는 것도 의미가 있었지만, 저는 개인적으로 윈도우즈 운영체제와는 다른 리눅스 우분투 운영체제를 사용해 코딩을 했다는점에서 새롭고 더 좋은 경험을 했다고 생각합니다. 더 나아가, 테스트 코드로 인해 코드를 계속 다듬으며 디버깅을 할수 있었으며 결과적으로 코드가 깔끔했으며 생산성 측면에서 효율성이 좋았습니다. 후에 제가 새로운 코딩작업을 하게된다면 테스트 코드를 먼저 작성한후에 코딩을 해야겠다고 생각했습니다. 하지만 시저사이퍼에서 이루어졌던 테스트 코드는 직접 만든게 아니라 주어진 테스트 코드였기때문에 테스트 코드 작성에 있어서는 지속적인 연습이 필요할것 같습니다.

3. 버스 시뮬레이터
  버스 시뮬레이터는 1학년 두번째 과제로서 초기에 간단하고 1차원적이었던 시뮬레이터를 수정, 보완해 기능을 향상시킨후 그래프로 분석하는 것이었습니다. 초기 버스 시뮬레이터는 한개의 라인이었으며 그 라인을 왕복하는 한대의 버스였습니다. 이 시뮬레이터는 불완전했으며 보완해야할 요소가 많았습니다. 예를들어, 버스가 오른쪽을 향할때에만 승객을 내려주고 태웠기때문에 승객이 원하는 목적지를 가기위해선 상당한 시간이 소요 될수 있었으며 버스에 인원 제한이 없었기 때문에 무한한 승객이 탈수있었습니다. 
  
  이 프로젝트에서 시뮬레이터의 기능을 향상시키기위해 첫번째로 버스 자체의 시스템에서의 수정과 보완이 있었고 두번째로 버스 이용자들에 관해서 기능적인 향상이 있었습니다. 우선 버스 자체 시스템 수정과 보완의 결과는 새로운 버스와 각기 다른 버스의 속도, 버스의 최대 수용인원 제한을 늘려주었고, 오른쪽으로 향할때만 승객을 승차시키고 하차시키던 버스의 문제점을 양방향으로 움직일때 가능하도록 해결했습니다. 또한 버스들에게 서로 다른 목적지를 향할수 있도록 만들어주기도 했습니다. 둘째로 버스 이용자들에 관한 기능적인 향상으로서는, 정류장에 있는 손님들이 버스를 탈때 소요되는 시간딜레이를 추가했으며 버스가 최대인원을 태움으로인해 타지 못하는 이용객들에게 기다린시간을 시간에따라 변하는 색으로 설정했습니다. 마지막으로는 완성된 시뮬레이터를 세가지 기준점(버스의 속도, 최대 수용인원, 버스의 댓수)에 변화를 주고 그래프적인 분석을 통해 버스 정류장에서 기다리는 사람들의 수를 측정하였습니다. 이유는 정류장에서 버스를 타기위해 늘어나는 손님들을 어느정도의 기준점의 변화를 주어야 효율적으로 통제할수 있는지 알기 위해서 였습니다.
  
  버스 시뮬레이터 성능향상은 가장 난이도가 높았던 코드였다고 생각합니다. 이유는 코드가 복잡했으며 여러곳에 걸쳐져있는 인과관계를 파악하는데에 어려움이 있었습니다. 가장 높은 점수를 받을수있던 Cost structure 기능 추가 혹은 직선이 아닌 곡선의 버스노선 디자인은 성취하지 못했지만 그래도 전체적인 코드를 이해했고 위에서 언급했던 기능적인 향상에대한 성취감을 얻었습니다. 처음에 눈으로만 코드를 훑어보았지만 가장 비효율적인 방법이라고 깨달았습니다. 문제집을 꼼꼼하게 읽고 복습하듯이 직접 얽혀있는 코드에 다가가 하나하나 분석을 하기시작했고 어느정도 인과관계를 파악한 후에는 무엇을 해야하는지 구도가 잡히기 시작했습니다. 제가 이번 과제를 통해 얻은 가장 큰 결실이었습니다. 마지막으로 한가지 아쉬웠던점은 더 깔끔한 코드를 만들수 있었을것 같습니다. 예를들어, 저는 새로운 버스를 추가할때 모든 코드에 bus2 변수를 추가해 코드의 길이가 비효율적으로 길어졌다고 느껴졌습니다. 후에는 더욱 복잡하고 얽혔있는 코드를 보다 꼼꼼히 분석한 후에 어떻게 간결하고 깔끔한 코드를 만들수 있을지 고민해볼것 같습니다.

4. 디지털 시스템 게이트 디자인
  디지털 시스템에서 사용되는 각종 장치(Latch and Multiplexer)들과 가장 작은단위의 게이트(Nand gate) 디자인들입니다. 코드의 틀은 기본적으로 가장 큰 단위인 Entity를 선언해줌으로서 인풋과 아웃풋을 지정해줘야하며, 다음으로 Entity보다는 더 작은 단위라고 볼수있는 Architecture를 선언해서 인풋이 어떤 값을 가졌을때 상응하는 결과값을 보여줄수 있는지 코드를 구성합니다. 이후에 테스트벤치 코드를 구성해야하는데, 테스트벤치는 아주 작은 시간단위에따라 가지는 결과값들을 테스트 하기위한 코드입니다.

5. 디지털 시스템 밀리머신과 무어머신 디자인
  밀리머신이란 출력이 현재의 상태와 입력에 의존한 머신입니다. 무어머신은 출력이 현재 상태에 의해서만 변하는 머신입니다. 각각 밀리머신과 무어머신의 코드설계는 첨부된 FSM(Finite State Machine: 유한상태기계 (설계도))에 의해 만들어졌습니다. 두 기계는 모두 차례대로 인풋이 1 0 1 0 이 들어온다면 현재의 상태가 1이되는 1010 Detector 입니다. 1010이 입력되지 않는다면 예를들어 1011110001 이라면 현재의 상태가 계속 0인상태로 State (FSM 그림 안에서 원)를 맴돌게 됩니다. 일반적인 디지털 시스템 코딩의 틀로서 Entity를 선언해 인풋과 아웃풋을 구성해주고 Architecture를 선언해 디자인 인풋에 대응하는 결과값들을 정해주었습니다.
  
  디지털 시스템에 대한 설계는 시작한지 오래되지 않았기때문에 가장 작은 소자들에대한 디자인부터 시작했습니다. 작은 게이트 장치들이모여 논리를 이루고 이런 논리들이 매일 쓰는 컴퓨터에 들어가는 작은 메모리가 되고 시스템이 된다는거에 대해 아직까지 신기하고 제 배움에대한 열정을 불태워줍니다. 디지털 머신에대한 코딩을 시작할때, 쉽지않았던 파이썬 언어에대한 어려움을 느꼈기때문에 디지털 시스템 코딩에대한 두려움도 있었습니다. 하지만 조금씩만 다를뿐 모두 같은 시스템 언어라는 것을 깨달았고 오히려 다른 툴을 사용한 언어를 사용한다고 하더라도 더 쉽고 빠르게 깨우칠수 있다고 자신합니다. 
