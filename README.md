# University_Programming_work
1. 고전 레이싱게임
  자율 과제 안에서 레이싱 게임을 만들자고 생각했던 계기는 기본적이면서도 간단 만들어서 기초를 다지기위해 이유였습니다. 이미지와 효과음 음악은 오픈소스에서 가져오면서 시작했습니다. 기본적인 배경을 설정해두고 케릭터에 방향키를 설정해준후에 각종 차가 랜덤으로 위에서 내려오는 방식으로 코딩을 했습니다. 스페이스바를 누른후 게임을 시작하며 유저 케릭터가 자동차와 충동하는순간 끝이납니다.
  
  spacebar를 눌러 게임을 시작합니다.
  기본적인 키는 방향키를 사용하여 오토바이를 움직입니다.
  오래 버틸수록 점수가 올라갑니다.
  R 키로 재시작이 가능합니다.
  P를 누르면 pause 기능이 있습니다.

2. 버스 시뮬레이터
  버스 시뮬레이터는 1학년 두번째 과제로서 초기에 주어진 간단한 버스시뮬레이터의 성능을 향상시키는 것이 초점이었습니다.초기 버스시뮬레이터는 하나의의 라인에 한대의 버스, 한정적인 수의 버스이용자와 이용자가 타면 내리지않는다는 문제점을 갖고 있었습니다. 이 프로젝트에서 시뮬레이터의 기능을 향상시키기위해 첫번째로 버스 자체의 시스템에서의 수정과 보완이 있었고 두번째로 버스 이용자들에 관해서 기능적인 향상이 있었으며 세번째로는 시뮬레이터의 그래프적인 분석이었습니다.

  우선 버스 자체 시스템 수정과 보완의 결과는 각기 다른 버스의 속도, 버스의 최대 수용인원 제한, 새로운 버스 그리고 버스의 서로다른 목적지 추가 입니다. 위 세가지 기능은 Objects.py 에서 각각 새로운 변수를 추가해주어서 수정했습니다.

  둘째로 버스 이용자들에 관한 기능적인 향상으로서는, 초기에 목적지가 정해져있었고 제한적이었던 버스 이용자들을의 성능을 향상시키기위해 버스 이용자가 원하는 목적지를 향하는 버스를 탈수 있도록 설정해두었습니다. 또한 버스 이용객 제한으로인해 타지 못하는 이용객들에게 기다린시간을 시간에따라 변하는 색으로 설정했습니다.

  마지막으로는 최종 버스 시뮬레이터에대한 그래프 분석입니다. 3가지 기준점을 잡고 버스 정류장에서 기다리는 사람들의 수 변화를 측정했습니다. 세가지 기준점은 버스의 속도, 최대 수용인원, 버스의 댓수입니다.

  버스 시뮬레이터의 목적은 초기에 간단하고 문제가 있었던 시뮬레이터를 수정, 보완해 기능을 향상시킨후 그래프로 분석함으로서 최적의 시뮬레이터를 만드는 것이었습니다. 결과적으로 현재 시뮬레이터의 적절한 속도는 각각 3, 4 그리고 5 이고, 버스의 댓수는 세대였으며, 버스의 최대인원은 8로서 최적의 효율을 나타내는 결과로 확인했습니다.

3. 시저사이퍼
  시저 사이퍼란 알파벳을 원하는 숫자만큼 평행으로 밀거나 당겨서 행해지는 암호화 입니다. 기본적인 시저사이퍼의 사용법은 Encrypt (E) Decrypy (D) 를 선택한후에 알파벳순서를 얼마만큼 쉬프트 하고싶은지 숫자를 선택후에 원하는 텍스트를 넣는 방법입니다. 예를들어, ./caesar_cipher.py d 5 Mjqqt Btwqi!인풋을 넣는다면 Hello World!의 아웃풋을 얻을수 있습니다. 이 워크는 우분투를 통해 이루어졌으며, 목적은 시저 사이퍼 코드를 설계하면서 주어진 테스트 벤치를통해 원하는 결과 값을 얻기 위함입니다.

4. 디지털 시스템 게이트 디자인
  디지털 시스템에서 사용되는 각종 장치들과 게이트 디자인들입니다. 기본적으로 가장 큰 단위인 Entity를 선언해줌으로서 인풋과 아웃풋을 지정해줘야하며, 다음으로 Entity보다는 더 작은 단위라고 볼수있는 Architecture를 선언해서 인풋이 어떤 값을 가졌을때 상응하는 결과값을 보여줄수 있는지 코드를 구성합니다. 이후에 테스트벤치 코드를 구성해야하는데, 테스트벤치는 아주 작은 시간단위에따라 가지는 결과값들을 테스트 하기위한 코드입니다.

5. 디지털 시스템 밀리머신과 무어머신 디자인
  밀리머신이란 출력이 현재의 상태와 입력에 의존한 머신입니다. 무어머신은 출력이 현재 상태에 의해서만 변하는 머신입니다. 각각 밀리머신과 무어머신의 코드설계는 첨부된 FSM(Finite State Machine: 유한상태기계 쉽게말해 설계도입니다)에 의해 만들어졌습니다. 일반적인 디지털 시스템 디자인과같이 Entity를 선언해 인풋과 아웃풋을 구성해주고 Architecture를 선언해 디자인 인풋에 대응하는 결과값들을 정해주었습니다.
  
