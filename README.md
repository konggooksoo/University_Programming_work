# University_Programming_work
1. 고전 레이싱게임
  처음으로 배운 파이썬 자율 과제 안에서 평소에 관심이 많던 게임을 만들자고 결심했고 기본적인 레이싱게임을 만들어서 기초를 다져야겠다고 생각했습니다. 이미지와 효과음들은 무료소스로서 차근차근 구체화 시켜나갔습니다. 기본적인 배경을 설정해두고 케릭터에 방향키를 설정해준후에 각종 차가 랜덤으로 위에서 내려오는 방식으로 코딩을 했습니다. 스페이스바를 누른후 게임을 시작하며 유저 케릭터가 자동차와 충돌하는순간 끝이납니다.
  
  spacebar를 눌러 게임을 시작합니다.
  기본적인 키는 방향키를 사용하여 오토바이를 움직입니다.
  오래 버틸수록 점수가 올라갑니다.
  R 키로 재시작이 가능합니다.
  P를 누르면 pause 기능이 있습니다.

2. 시저사이퍼
  시저 사이퍼란 알파벳을 원하는 숫자만큼 평행으로 밀거나 당겨서 행해지는 암호화 입니다. 기본적인 시저사이퍼의 사용법은 Encrypt (E) Decrypt (D) 를 선택한후에 알파벳순서를 얼마만큼 쉬프트 하고싶은지 숫자를 선택후에 원하는 텍스트를 넣는 방법입니다. 예를들어, ./caesar_cipher.py d 5 Mjqqt Btwqi!인풋을 넣는다면 Hello World!의 아웃풋을 얻을수 있습니다. 이 워크는 우분투를 통해 이루어졌으며, 시저 사이퍼 코드를 설계하면서 주어진 테스트 코드를 통해 원하는 결과 값을 얻기 위함입니다. 테스트 코드로 인해 코드를 계속 다듬으며 디버깅을 할수 있었으며 결과적으로 코드가 깔끔했으며 생산성 측면에서 효율성이 좋았습니다.

3. 버스 시뮬레이터
  버스 시뮬레이터는 1학년 두번째 과제로서 초기에 간단하고 1차원적이었던 시뮬레이터를 수정, 보완해 기능을 향상시킨후 그래프로 분석하는 것이었습니다. 초기 버스 시뮬레이터는 한개의 라인이었으며 그 라인을 왕복하는 한대의 버스였습니다. 이 시뮬레이터는 불완전했으며 보완해야할 요소가 많았습니다. 예를들어, 버스가 오른쪽을 향할때에만 승객을 내려주고 태웠기때문에 승객이 원하는 목적지를 가기위해선 상당한 시간이 소요 될수 있었으며 버스에 인원 제한이 없었기 때문에 무한한 승객이 탈수있었습니다. 
  이 프로젝트에서 시뮬레이터의 기능을 향상시키기위해 첫번째로 버스 자체의 시스템에서의 수정과 보완이 있었고 두번째로 버스 이용자들에 관해서 기능적인 향상이 있었습니다. 우선 버스 자체 시스템 수정과 보완의 결과는 새로운 버스와 각기 다른 버스의 속도, 버스의 최대 수용인원 제한을 늘려주었고, 오른쪽으로 향할때만 승객을 승차시키고 하차시키던 버스의 문제점을 양방향으로 움직일때 가능하도록 해결했습니다. 또한 버스들에게 서로 다른 목적지를 향할수 있도록 만들어주기도 했습니다. 둘째로 버스 이용자들에 관한 기능적인 향상으로서는, 정류장에 있는 손님들이 버스를 탈때 소요되는 시간딜레이를 추가했으며 버스가 최대인원을 태움으로인해 타지 못하는 이용객들에게 기다린시간을 시간에따라 변하는 색으로 설정했습니다. 마지막으로는 완성된 시뮬레이터를 세가지 기준점(버스의 속도, 최대 수용인원, 버스의 댓수)에 변화를 주고 그래프적인 분석을 통해 버스 정류장에서 기다리는 사람들의 수를 측정하였습니다. 이유는 정류장에서 버스를 타기위해 늘어나는 손님들을 어느정도의 기준점의 변화를 주어야 효율적으로 통제할수 있는지 알기 위해서 였습니다.

4. 디지털 시스템 게이트 디자인
  디지털 시스템에서 사용되는 각종 장치(Latch and Multiplexer)들과 가장 작은단위의 게이트(Nand gate) 디자인들입니다. 코드의 틀은 기본적으로 가장 큰 단위인 Entity를 선언해줌으로서 인풋과 아웃풋을 지정해줘야하며, 다음으로 Entity보다는 더 작은 단위라고 볼수있는 Architecture를 선언해서 인풋이 어떤 값을 가졌을때 상응하는 결과값을 보여줄수 있는지 코드를 구성합니다. 이후에 테스트벤치 코드를 구성해야하는데, 테스트벤치는 아주 작은 시간단위에따라 가지는 결과값들을 테스트 하기위한 코드입니다.

5. 디지털 시스템 밀리머신과 무어머신 디자인
  밀리머신이란 출력이 현재의 상태와 입력에 의존한 머신입니다. 무어머신은 출력이 현재 상태에 의해서만 변하는 머신입니다. 각각 밀리머신과 무어머신의 코드설계는 첨부된 FSM(Finite State Machine: 유한상태기계 (설계도))에 의해 만들어졌습니다. 두 기계는 모두 차례대로 인풋이 1 0 1 0 이 들어온다면 현재의 상태가 1이되는 1010 Detector 입니다. 1010이 입력되지 않는다면 예를들어 1011110001 이라면 현재의 상태가 계속 0인상태로 State (FSM 그림 안에서 원)를 맴돌게 됩니다. 일반적인 디지털 시스템 코딩의 틀로서 Entity를 선언해 인풋과 아웃풋을 구성해주고 Architecture를 선언해 디자인 인풋에 대응하는 결과값들을 정해주었습니다.
